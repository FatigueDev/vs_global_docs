{
  "api/VSGlobal.EventArguments.OnPayloadReceivedEventArgs.html": {
    "href": "api/VSGlobal.EventArguments.OnPayloadReceivedEventArgs.html",
    "title": "Class OnPayloadReceivedEventArgs | VS Global Docs",
    "keywords": "Class OnPayloadReceivedEventArgs Namespace VSGlobal.EventArguments Assembly VSGlobal.dll Provides Payload public class OnPayloadReceivedEventArgs : EventArgs Inheritance object EventArgs OnPayloadReceivedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields payload public required Payload payload Field Value Payload"
  },
  "api/VSGlobal.EventArguments.html": {
    "href": "api/VSGlobal.EventArguments.html",
    "title": "Namespace VSGlobal.EventArguments | VS Global Docs",
    "keywords": "Namespace VSGlobal.EventArguments Classes OnPayloadReceivedEventArgs Provides Payload"
  },
  "api/VSGlobal.Events.html": {
    "href": "api/VSGlobal.Events.html",
    "title": "Class Events | VS Global Docs",
    "keywords": "Class Events Namespace VSGlobal Assembly VSGlobal.dll Events allow you to add callbacks to VSGlobal's events: OnConnect OnDisconnect OnError OnPayloadReceived public static class Events Inheritance object Events Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Events OnConnect Invoked when VSGlobal has connected Using a lambda: VSGlobal.Events.OnConnect += (e) => { // Do stuff on connect VSGlobal.Subscribe(\"my_module\"); VSGlobal.Broadcast(\"Hello World!\", \"my_module\"); //> OnPayloadReceived }; Using a function: public void MyCoolOnConnect(EventArgs e) { // Do stuff on connect } // Then later, in a function body somewhere we register the handler. VSGlobal.Events.OnConnect += MyCoolOnConnect; public static event OnConnectHandler OnConnect Event Type OnConnectHandler OnDisconnect Invoked when VsGlobal has disconnected (banned, server issue, skill issue) Using a lambda: Events.OnDisconnect += (e) => { // Do stuff on disconnect }; Using a function: public void MyCoolOnDisconnect(EventArgs e) { // Do stuff on disconnect } // Then later, in a function body somewhere we register the handler. Events.OnDisconnect += MyCoolOnDisconnect; public static event OnDisconnectHandler OnDisconnect Event Type OnDisconnectHandler OnError Events.OnError += (e) => { // Do stuff on disconnect Console.WriteLine(e.Exception); Console.WriteLine(e.Message); }; Using a function: public void MyCoolOnDisconnect(WebSocketSharper.ErrorEventArgs e) { // Do stuff on disconnect } // Then later, in a function body somewhere we register the handler. Events.OnError += MyCoolOnDisconnect; public static event OnErrorHandler OnError Event Type OnErrorHandler OnPayloadReceived Invoked when VsGlobal receives a payload Using a lambda: Events.OnPayloadReceived += (e) => { // This will be called whenever a packet arrives, regardless of module or sender. if(e.payload.Module == \"my_module_name\") { // Now that we know the payload is for our module, we can try converting it to our expected types. MyCustomClass? myCustomThing = e.payload.DeserializePacket<MyCustomClass>(); if(myCustomThing is MyCustomClass packet) { DoSomething(myCustomThing.value); } } else { // It's someone else's packet. Could be handy for extension mods! } }; Using a function: public void ReceiveMessagePacket(OnPayloadReceivedEventArgs e) { // Same as the lambda, we have access to any payload coming in here. Message? maybeMessage = e.payload.DeserializePacket<Message>(); // We can also be quite cheeky and attempt to deserialize it to our custom type regardless of module. // If it doesn't, it's not ours- So I suppose that's valid as well. if(maybeMessage is Message msg) { // Do something with our received custom message! } } // Ideally, within `public override void StartClientside(ICoreClientAPI)` Events.OnPayloadReceived += ReceiveMessagePacket; public static event OnPayloadReceivedHandler OnPayloadReceived Event Type OnPayloadReceivedHandler See Also OnPayloadReceivedEventArgs See Also VSGlobal.EventArguments"
  },
  "api/VSGlobal.Logger.html": {
    "href": "api/VSGlobal.Logger.html",
    "title": "Class Logger | VS Global Docs",
    "keywords": "Class Logger Namespace VSGlobal Assembly VSGlobal.dll public class Logger : ILogger Inheritance object Logger Implements ILogger Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Logger(ICoreClientAPI) public Logger(ICoreClientAPI api) Parameters api ICoreClientAPI Methods BeginScope<TState>(TState) Begins a logical operation scope. public IDisposable BeginScope<TState>(TState state) Parameters state TState The identifier for the scope. Returns IDisposable An IDisposable that ends the logical operation scope on dispose. Type Parameters TState The type of the state to begin scope for. IsEnabled(LogLevel) Checks if the given logLevel is enabled. public bool IsEnabled(LogLevel logLevel) Parameters logLevel LogLevel Level to be checked. Returns bool true if enabled. Log<TState>(LogLevel, EventId, TState, Exception?, Func<TState, Exception?, string>) Writes a log entry. public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter) Parameters logLevel LogLevel Entry will be written on this level. eventId EventId Id of the event. state TState The entry to be written. Can be also an object. exception Exception The exception related to this entry. formatter Func<TState, Exception, string> Function to create a string message of the state and exception. Type Parameters TState The type of the object to be written."
  },
  "api/VSGlobal.Network.html": {
    "href": "api/VSGlobal.Network.html",
    "title": "Class Network | VS Global Docs",
    "keywords": "Class Network Namespace VSGlobal Assembly VSGlobal.dll Network allow you to send payloads to those who are subscribed to an endpoint (or multiple endpoints): Broadcast<T>(T, string) Subscribe(string) public static class Network Inheritance object Network Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Broadcast<T>(T, string) Called when you want to broadcast to one of your subscribed locations. You must call VSGlobal.Network.Subscribe(\"name_of_my_module_or_my_mod_id\") prior to using Broadcast. Try not to use \"core\". If we are not connected to core, the packet will be dropped safely and the event logged. Example with a custom network message: //First, we define our network packet somewhere like so. [ProtoContract(ImplicitFields = ImplicitFields.AllPublic)] public class CustomNetworkMessage { public bool didSomething; public IClientPlayer sender; public string message = \"Default Message\"; } // Later on, in a function body ... // All we have to do is call broadcast. It's generic, so you can throw _anything_ in there. string, class, struct- Whatever. VsGlobal.Broadcast(new CustomNetworkMessage() { didSomething = true, sender = api.World.Player, message = \"Grungus\" }, \"broadcast\", \"my_module\"); // What that will do is send the packet to the server and relay it to others. // Once received, it'll invoke Events.OnPayloadReceived public static Task Broadcast<T>(T packet, string module) Parameters packet T module string Returns Task Type Parameters T See Also OnPayloadReceived Subscribe(string) Subscribe to a module to received broadcasted packets from. Call this from OnConnect public static Task Subscribe(string module) Parameters module string Our mod's ID, or any underscore separated string. E.g. \"global_chat\" or \"hungry_hungry_hippo\" Returns Task"
  },
  "api/VSGlobal.Proto.Payload.html": {
    "href": "api/VSGlobal.Proto.Payload.html",
    "title": "Class Payload | VS Global Docs",
    "keywords": "Class Payload Namespace VSGlobal.Proto Assembly VSGlobal.dll [ProtoContract] public class Payload Inheritance object Payload Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PayloadExtensionMethods.DeserializePacket<T>(Payload) PayloadExtensionMethods.Serialize(Payload) PayloadExtensionMethods.Serialize<T>(Payload, T) Constructors Payload() public Payload() Payload(string) public Payload(string triggerEvent) Parameters triggerEvent string Payload(string, string) public Payload(string triggerEvent, string module) Parameters triggerEvent string module string Properties Event [ProtoMember(2)] public string Event { get; set; } Property Value string Module [ProtoMember(1)] public string Module { get; set; } Property Value string PacketType [ProtoMember(3)] public string PacketType { get; set; } Property Value string PacketValue [ProtoMember(4)] public byte[] PacketValue { get; set; } Property Value byte[] Methods Deserialize(byte[], int) public static Payload Deserialize(byte[] buffer, int responseSize) Parameters buffer byte[] responseSize int Returns Payload"
  },
  "api/VSGlobal.Proto.PayloadExtensionMethods.html": {
    "href": "api/VSGlobal.Proto.PayloadExtensionMethods.html",
    "title": "Class PayloadExtensionMethods | VS Global Docs",
    "keywords": "Class PayloadExtensionMethods Namespace VSGlobal.Proto Assembly VSGlobal.dll public static class PayloadExtensionMethods Inheritance object PayloadExtensionMethods Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeserializePacket<T>(Payload) public static T? DeserializePacket<T>(this Payload payload) Parameters payload Payload Returns T Type Parameters T Serialize(Payload) public static byte[] Serialize(this Payload payload) Parameters payload Payload Returns byte[] Serialize<T>(Payload, T) public static byte[] Serialize<T>(this Payload payload, T packetValue) Parameters payload Payload packetValue T Returns byte[] Type Parameters T"
  },
  "api/VSGlobal.Proto.html": {
    "href": "api/VSGlobal.Proto.html",
    "title": "Namespace VSGlobal.Proto | VS Global Docs",
    "keywords": "Namespace VSGlobal.Proto Classes Payload PayloadExtensionMethods"
  },
  "api/VSGlobal.VSGlobalModSystem.html": {
    "href": "api/VSGlobal.VSGlobalModSystem.html",
    "title": "Class VSGlobalModSystem | VS Global Docs",
    "keywords": "Class VSGlobalModSystem Namespace VSGlobal Assembly VSGlobal.dll public class VSGlobalModSystem : ModSystem Inheritance object ModSystem VSGlobalModSystem Inherited Members ModSystem.ShouldLoad(EnumAppSide) ModSystem.StartPre(ICoreAPI) ModSystem.Start(ICoreAPI) ModSystem.AssetsLoaded(ICoreAPI) ModSystem.AssetsFinalize(ICoreAPI) ModSystem.StartServerSide(ICoreServerAPI) ModSystem.Dispose() ModSystem.Mod object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExecuteOrder() If you need mods to be executed in a certain order, adjust this methods return value. The server will call each Mods StartPre() and Start() methods in ascending order of each mods execute order value. And thus, as long as every mod registers it's event handlers in the Start() method, all event handlers will be called in the same execution order. Default execute order of some survival mod parts Worldgen: GenTerra: 0 RockStrata: 0.1 Deposits: 0.2 Caves: 0.3 Blocklayers: 0.4 AssetsLoaded event JsonPatch loader: 0.05 Load hardcoded mantle block: 0.1 Block and Item Loader: 0.2 Recipes (Smithing, Knapping, Clayforming, Grid recipes, Alloys) Loader: 1 public override double ExecuteOrder() Returns double StartClientSide(ICoreClientAPI) Full start to the mod on the client side. Note, in multiplayer games, the server assets (blocks, items, entities, recipes) have not yet been received and so no blocks etc. are yet registered For code that must run only after we have blocks, items, entities and recipes all registered and loaded, add your method to event BlockTexturesLoaded public override void StartClientSide(ICoreClientAPI api) Parameters api ICoreClientAPI"
  },
  "api/VSGlobal.html": {
    "href": "api/VSGlobal.html",
    "title": "Namespace VSGlobal | VS Global Docs",
    "keywords": "Namespace VSGlobal Classes Events Events allow you to add callbacks to VSGlobal's events: OnConnect OnDisconnect OnError OnPayloadReceived Network Network allow you to send payloads to those who are subscribed to an endpoint (or multiple endpoints): Broadcast<T>(T, string) Subscribe(string)"
  },
  "api/VsGlobal.AuthToken.Config.html": {
    "href": "api/VsGlobal.AuthToken.Config.html",
    "title": "Class Config | VS Global Docs",
    "keywords": "Class Config Namespace VsGlobal.AuthToken Assembly VSGlobal.dll public static class Config Inheritance object Config Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods TryGetAuthToken(ICoreClientAPI) public static Guid? TryGetAuthToken(ICoreClientAPI capi) Parameters capi ICoreClientAPI Returns Guid?"
  },
  "api/VsGlobal.AuthToken.html": {
    "href": "api/VsGlobal.AuthToken.html",
    "title": "Namespace VsGlobal.AuthToken | VS Global Docs",
    "keywords": "Namespace VsGlobal.AuthToken Classes Config"
  },
  "api/VsGlobal.Config.html": {
    "href": "api/VsGlobal.Config.html",
    "title": "Struct Config | VS Global Docs",
    "keywords": "Struct Config Namespace VsGlobal Assembly VSGlobal.dll Contains the api, player, their auth_token and module (\"core\"). public struct Config Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields api public ICoreClientAPI api Field Value ICoreClientAPI module public string module Field Value string player public IClientPlayer player Field Value IClientPlayer token public Guid token Field Value Guid"
  },
  "api/VsGlobal.EventArguments.OnClientReadyEventArgs.html": {
    "href": "api/VsGlobal.EventArguments.OnClientReadyEventArgs.html",
    "title": "Class OnClientReadyEventArgs | VS Global Docs",
    "keywords": "Class OnClientReadyEventArgs Namespace VsGlobal.EventArguments Assembly VSGlobal.dll Provides Config config public class OnClientReadyEventArgs : EventArgs Inheritance object EventArgs OnClientReadyEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields config public required Config config Field Value Config"
  },
  "api/VsGlobal.EventArguments.OnConnectEventArgs.html": {
    "href": "api/VsGlobal.EventArguments.OnConnectEventArgs.html",
    "title": "Class OnConnectEventArgs | VS Global Docs",
    "keywords": "Class OnConnectEventArgs Namespace VsGlobal.EventArguments Assembly VSGlobal.dll Provides string module public class OnConnectEventArgs : EventArgs Inheritance object EventArgs OnConnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields module public required string module Field Value string"
  },
  "api/VsGlobal.EventArguments.OnDisconnectEventArgs.html": {
    "href": "api/VsGlobal.EventArguments.OnDisconnectEventArgs.html",
    "title": "Class OnDisconnectEventArgs | VS Global Docs",
    "keywords": "Class OnDisconnectEventArgs Namespace VsGlobal.EventArguments Assembly VSGlobal.dll Provides string module public class OnDisconnectEventArgs : EventArgs Inheritance object EventArgs OnDisconnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields module public required string module Field Value string"
  },
  "api/VsGlobal.EventArguments.OnPayloadReceivedEventArgs.html": {
    "href": "api/VsGlobal.EventArguments.OnPayloadReceivedEventArgs.html",
    "title": "Class OnPayloadReceivedEventArgs | VS Global Docs",
    "keywords": "Class OnPayloadReceivedEventArgs Namespace VsGlobal.EventArguments Assembly VSGlobal.dll Provides Payload payload public class OnPayloadReceivedEventArgs : EventArgs Inheritance object EventArgs OnPayloadReceivedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields payload public required Payload payload Field Value Payload"
  },
  "api/VsGlobal.EventArguments.OnReconnectEventArgs.html": {
    "href": "api/VsGlobal.EventArguments.OnReconnectEventArgs.html",
    "title": "Class OnReconnectEventArgs | VS Global Docs",
    "keywords": "Class OnReconnectEventArgs Namespace VsGlobal.EventArguments Assembly VSGlobal.dll Provides string module, int attempts public class OnReconnectEventArgs : EventArgs Inheritance object EventArgs OnReconnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields attempts public required int attempts Field Value int module public required string module Field Value string"
  },
  "api/VsGlobal.EventArguments.html": {
    "href": "api/VsGlobal.EventArguments.html",
    "title": "Namespace VsGlobal.EventArguments | VS Global Docs",
    "keywords": "Namespace VsGlobal.EventArguments Classes OnClientReadyEventArgs Provides Config config OnConnectEventArgs Provides string module OnDisconnectEventArgs Provides string module OnPayloadReceivedEventArgs Provides Payload payload OnReconnectEventArgs Provides string module, int attempts"
  },
  "api/VsGlobal.Events.html": {
    "href": "api/VsGlobal.Events.html",
    "title": "Class Events | VS Global Docs",
    "keywords": "Class Events Namespace VsGlobal Assembly VSGlobal.dll Events allows you to add callbacks to VsGlobal events. Using a lambda: Events.OnConnect += (e) => {}; // Where e is type OnConnectEventArgs Using a function: public void MyCustomHandler(OnPayloadReceivedEventArgs e) { Console.WriteLine(e.payload.Module); // \"core\" } Events.OnPayloadReceived += MyCustomHandler; public static class Events Inheritance object Events Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Events OnClientReady Invoked when the ICoreClientAPI.World.Player is fully loaded Using a lambda: Events.OnClientReady += (e) => { e.config.api.Logger.Info(e.config.module); }; Using a function: public void MyCoolOnClientReady(OnClientReadyEventArgs e) { // Do some stuff with e.config e.config.api.ShowChatMessage(e.config.player.PlayerName); } // Then later, in a function body somewhere we register the handler. Events.OnClientReady += MyCoolOnClientReady; public static event OnClientReadyHandler OnClientReady Event Type OnClientReadyHandler See Also OnClientReadyEventArgs OnConnect Invoked when VsGlobal has connected Using a lambda: Events.OnConnect += (e) => { if(e.module == \"my_module_name\") { // Do stuff just for our module! } else { // Do stuff for any other module! } }; Using a function: public void MyCoolOnConnect(OnConnectedEventArgs e) { // Do some stuff with e.module } // Then later, in a function body somewhere we register the handler. Events.OnConnect += MyCoolOnConnect; public static event OnConnectHandler OnConnect Event Type OnConnectHandler See Also OnConnectEventArgs OnDisconnect Invoked when VsGlobal has disconnected (banned, server issue, skill issue) Using a lambda: Events.OnDisconnect += (e) => { if(e.module == \"my_module_name\") { // Cleanup our mod code because we're DC'd. } else { // Likely don't care, but might care. } }; Using a function: public void MyCoolOnDisconnect(OnDisconnectEventArgs e) { // Do some stuff with e.module } // Then later, in a function body somewhere we register the handler. Events.OnDisconnect += MyCoolOnDisconnect; public static event OnDisconnectHandler OnDisconnect Event Type OnDisconnectHandler See Also OnDisconnectEventArgs OnPayloadReceived Invoked when VsGlobal receives a payload Using a lambda: Events.OnPayloadReceived += (e) => { // This will be called whenever a packet arrives, regardless of module or sender. if(e.payload.Module == \"my_module_name\") { // Now that we know the payload is for our module, we can try converting it to our expected types. MyCustomClass? myCustomThing = e.payload.DeserializePacket<MyCustomClass>(); if(myCustomThing is MyCustomClass packet) { DoSomething(myCustomThing.value); } } else { // It's someone else's packet. Could be handy for extension mods! } }; Using a function: public void ReceiveMessagePacket(OnPayloadReceivedEventArgs e) { // Same as the lambda, we have access to any payload coming in here. Message? maybeMessage = e.payload.DeserializePacket<Message>(); // We can also be quite cheeky and attempt to deserialize it to our custom type regardless of module. // If it doesn't, it's not ours- So I suppose that's valid as well. if(maybeMessage is Message msg) { // Do something with our received custom message! } } // Ideally, within `public override void StartClientside(ICoreClientAPI)` Events.OnPayloadReceived += ReceiveMessagePacket; public static event OnPayloadReceivedHandler OnPayloadReceived Event Type OnPayloadReceivedHandler See Also OnPayloadReceivedEventArgs OnReconnect Invoked when VsGlobal is trying to reconnect Using a lambda: Events.OnReconnect += (e) => { if(e.module == \"my_module_name\") { // Cleanup our mod code because we're DC'd. var myValue = e.attempts; } else { // Likely don't care, but might care. } }; Using a function: public void MyCoolOnReconnect(OnReconnectEventArgs e) { if(e.attempts == 3 && e.module == \"my_module_name\") { /* Do stuff */ } } // Then later, in a function body somewhere we register the handler. Events.OnReconnect += MyCoolOnReconnect; public static event OnReconnectHandler OnReconnect Event Type OnReconnectHandler See Also OnReconnectEventArgs See Also VsGlobal.EventArguments"
  },
  "api/VsGlobal.Handlers.OnClientReadyHandler.html": {
    "href": "api/VsGlobal.Handlers.OnClientReadyHandler.html",
    "title": "Delegate OnClientReadyHandler | VS Global Docs",
    "keywords": "Delegate OnClientReadyHandler Namespace VsGlobal.Handlers Assembly VSGlobal.dll public delegate void OnClientReadyHandler(OnClientReadyEventArgs e) Parameters e OnClientReadyEventArgs"
  },
  "api/VsGlobal.Handlers.OnConnectHandler.html": {
    "href": "api/VsGlobal.Handlers.OnConnectHandler.html",
    "title": "Delegate OnConnectHandler | VS Global Docs",
    "keywords": "Delegate OnConnectHandler Namespace VsGlobal.Handlers Assembly VSGlobal.dll public delegate void OnConnectHandler(OnConnectEventArgs e) Parameters e OnConnectEventArgs"
  },
  "api/VsGlobal.Handlers.OnDisconnectHandler.html": {
    "href": "api/VsGlobal.Handlers.OnDisconnectHandler.html",
    "title": "Delegate OnDisconnectHandler | VS Global Docs",
    "keywords": "Delegate OnDisconnectHandler Namespace VsGlobal.Handlers Assembly VSGlobal.dll public delegate void OnDisconnectHandler(OnDisconnectEventArgs e) Parameters e OnDisconnectEventArgs"
  },
  "api/VsGlobal.Handlers.OnPayloadReceivedHandler.html": {
    "href": "api/VsGlobal.Handlers.OnPayloadReceivedHandler.html",
    "title": "Delegate OnPayloadReceivedHandler | VS Global Docs",
    "keywords": "Delegate OnPayloadReceivedHandler Namespace VsGlobal.Handlers Assembly VSGlobal.dll public delegate void OnPayloadReceivedHandler(OnPayloadReceivedEventArgs e) Parameters e OnPayloadReceivedEventArgs"
  },
  "api/VsGlobal.Handlers.OnReconnectHandler.html": {
    "href": "api/VsGlobal.Handlers.OnReconnectHandler.html",
    "title": "Delegate OnReconnectHandler | VS Global Docs",
    "keywords": "Delegate OnReconnectHandler Namespace VsGlobal.Handlers Assembly VSGlobal.dll public delegate void OnReconnectHandler(OnReconnectEventArgs e) Parameters e OnReconnectEventArgs"
  },
  "api/VsGlobal.Handlers.html": {
    "href": "api/VsGlobal.Handlers.html",
    "title": "Namespace VsGlobal.Handlers | VS Global Docs",
    "keywords": "Namespace VsGlobal.Handlers Delegates OnClientReadyHandler OnConnectHandler OnDisconnectHandler OnPayloadReceivedHandler OnReconnectHandler"
  },
  "api/VsGlobal.Network.html": {
    "href": "api/VsGlobal.Network.html",
    "title": "Class Network | VS Global Docs",
    "keywords": "Class Network Namespace VsGlobal Assembly VSGlobal.dll public static class Network Inheritance object Network Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Broadcast<T>(T, string?) Called when you want to broadcast to the server. Note; we don't have to be connected to call this. It's thread safe and sitting there patiently for the websocket state to be 'Open' (connected) Example with a custom network message: //First, we define our network packet somewhere like so. [ProtoContract(ImplicitFields = ImplicitFields.AllPublic)] public class CustomNetworkMessage { public bool didSomething; public IClientPlayer sender; public string message = \"Default Message\"; } // Later on, in a function body ... // All we have to do is call broadcast. It's generic, so you can throw _anything_ in there. string, class, struct- Whatever. VsGlobal.Broadcast(new CustomNetworkMessage(){didSomething = true, sender = api.World.Player, message = \"Grungus\"}); // What that will do is send the packet to the server and relay it to others. // Once received, it'll invoke Events.OnPayloadReceived public static void Broadcast<T>(T packet, string? module = null) Parameters packet T module string Type Parameters T"
  },
  "api/VsGlobal.NetworkInternals.html": {
    "href": "api/VsGlobal.NetworkInternals.html",
    "title": "Class NetworkInternals | VS Global Docs",
    "keywords": "Class NetworkInternals Namespace VsGlobal Assembly VSGlobal.dll public static class NetworkInternals Inheritance object NetworkInternals Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods _GetClientWebsocket() public static ClientWebSocket _GetClientWebsocket() Returns ClientWebSocket _GetDefaultModuleName() public static string _GetDefaultModuleName() Returns string _Initialize(ICoreClientAPI) public static void _Initialize(ICoreClientAPI api) Parameters api ICoreClientAPI _SetupHandlers(ICoreClientAPI) public static void _SetupHandlers(ICoreClientAPI api) Parameters api ICoreClientAPI"
  },
  "api/VsGlobal.OnClientReadyEventArgs.html": {
    "href": "api/VsGlobal.OnClientReadyEventArgs.html",
    "title": "Class OnClientReadyEventArgs | VS Global Docs",
    "keywords": "Class OnClientReadyEventArgs Namespace VsGlobal Assembly VSGlobal.dll public class OnClientReadyEventArgs : EventArgs Inheritance object EventArgs OnClientReadyEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields config public required Config config Field Value Config"
  },
  "api/VsGlobal.OnClientReadyHandler.html": {
    "href": "api/VsGlobal.OnClientReadyHandler.html",
    "title": "Delegate OnClientReadyHandler | VS Global Docs",
    "keywords": "Delegate OnClientReadyHandler Namespace VsGlobal Assembly VSGlobal.dll public delegate void OnClientReadyHandler(OnClientReadyEventArgs e) Parameters e OnClientReadyEventArgs"
  },
  "api/VsGlobal.OnConnectEventArgs.html": {
    "href": "api/VsGlobal.OnConnectEventArgs.html",
    "title": "Class OnConnectEventArgs | VS Global Docs",
    "keywords": "Class OnConnectEventArgs Namespace VsGlobal Assembly VSGlobal.dll public class OnConnectEventArgs : EventArgs Inheritance object EventArgs OnConnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields module public required string module Field Value string"
  },
  "api/VsGlobal.OnConnectHandler.html": {
    "href": "api/VsGlobal.OnConnectHandler.html",
    "title": "Delegate OnConnectHandler | VS Global Docs",
    "keywords": "Delegate OnConnectHandler Namespace VsGlobal Assembly VSGlobal.dll public delegate void OnConnectHandler(OnConnectEventArgs e) Parameters e OnConnectEventArgs"
  },
  "api/VsGlobal.OnDisconnectEventArgs.html": {
    "href": "api/VsGlobal.OnDisconnectEventArgs.html",
    "title": "Class OnDisconnectEventArgs | VS Global Docs",
    "keywords": "Class OnDisconnectEventArgs Namespace VsGlobal Assembly VSGlobal.dll public class OnDisconnectEventArgs : EventArgs Inheritance object EventArgs OnDisconnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields module public required string module Field Value string"
  },
  "api/VsGlobal.OnDisconnectHandler.html": {
    "href": "api/VsGlobal.OnDisconnectHandler.html",
    "title": "Delegate OnDisconnectHandler | VS Global Docs",
    "keywords": "Delegate OnDisconnectHandler Namespace VsGlobal Assembly VSGlobal.dll public delegate void OnDisconnectHandler(OnDisconnectEventArgs e) Parameters e OnDisconnectEventArgs"
  },
  "api/VsGlobal.OnPayloadReceivedEventArgs.html": {
    "href": "api/VsGlobal.OnPayloadReceivedEventArgs.html",
    "title": "Class OnPayloadReceivedEventArgs | VS Global Docs",
    "keywords": "Class OnPayloadReceivedEventArgs Namespace VsGlobal Assembly VSGlobal.dll public class OnPayloadReceivedEventArgs : EventArgs Inheritance object EventArgs OnPayloadReceivedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields payload public required Payload payload Field Value Payload"
  },
  "api/VsGlobal.OnPayloadReceivedHandler.html": {
    "href": "api/VsGlobal.OnPayloadReceivedHandler.html",
    "title": "Delegate OnPayloadReceivedHandler | VS Global Docs",
    "keywords": "Delegate OnPayloadReceivedHandler Namespace VsGlobal Assembly VSGlobal.dll public delegate void OnPayloadReceivedHandler(OnPayloadReceivedEventArgs e) Parameters e OnPayloadReceivedEventArgs"
  },
  "api/VsGlobal.OnReconnectEventArgs.html": {
    "href": "api/VsGlobal.OnReconnectEventArgs.html",
    "title": "Class OnReconnectEventArgs | VS Global Docs",
    "keywords": "Class OnReconnectEventArgs Namespace VsGlobal Assembly VSGlobal.dll public class OnReconnectEventArgs : EventArgs Inheritance object EventArgs OnReconnectEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields attempts public required int attempts Field Value int module public required string module Field Value string"
  },
  "api/VsGlobal.OnReconnectHandler.html": {
    "href": "api/VsGlobal.OnReconnectHandler.html",
    "title": "Delegate OnReconnectHandler | VS Global Docs",
    "keywords": "Delegate OnReconnectHandler Namespace VsGlobal Assembly VSGlobal.dll public delegate void OnReconnectHandler(OnReconnectEventArgs e) Parameters e OnReconnectEventArgs"
  },
  "api/VsGlobal.Packets.Extensions.html": {
    "href": "api/VsGlobal.Packets.Extensions.html",
    "title": "Class Extensions | VS Global Docs",
    "keywords": "Class Extensions Namespace VsGlobal.Packets Assembly VSGlobal.dll public static class Extensions Inheritance object Extensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeserializePacket<T>(Payload) public static T? DeserializePacket<T>(this Payload payload) Parameters payload Payload Returns T Type Parameters T Serialize<T>(Payload, T) public static byte[] Serialize<T>(this Payload payload, T packetValue) Parameters payload Payload packetValue T Returns byte[] Type Parameters T"
  },
  "api/VsGlobal.Packets.Message.html": {
    "href": "api/VsGlobal.Packets.Message.html",
    "title": "Class Message | VS Global Docs",
    "keywords": "Class Message Namespace VsGlobal.Packets Assembly VSGlobal.dll [ProtoContract(ImplicitFields = ImplicitFields.AllPublic)] public class Message Inheritance object Message Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields text public string text Field Value string"
  },
  "api/VsGlobal.Packets.Payload.html": {
    "href": "api/VsGlobal.Packets.Payload.html",
    "title": "Class Payload | VS Global Docs",
    "keywords": "Class Payload Namespace VsGlobal.Packets Assembly VSGlobal.dll [ProtoContract] public class Payload Inheritance object Payload Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods Extensions.DeserializePacket<T>(Payload) Extensions.Serialize<T>(Payload, T) Constructors Payload() public Payload() Payload(string) public Payload(string module) Parameters module string Properties Module [ProtoMember(1)] public string Module { get; set; } Property Value string PacketType [ProtoMember(3)] public string PacketType { get; set; } Property Value string PacketValue [ProtoMember(4)] public byte[] PacketValue { get; set; } Property Value byte[] Processed [ProtoMember(2)] public bool Processed { get; set; } Property Value bool Methods Deserialize(byte[], int) public static Payload Deserialize(byte[] buffer, int responseSize) Parameters buffer byte[] responseSize int Returns Payload"
  },
  "api/VsGlobal.Packets.html": {
    "href": "api/VsGlobal.Packets.html",
    "title": "Namespace VsGlobal.Packets | VS Global Docs",
    "keywords": "Namespace VsGlobal.Packets Classes Extensions Message Payload"
  },
  "api/VsGlobal.Proto.Payload.html": {
    "href": "api/VsGlobal.Proto.Payload.html",
    "title": "Class Payload | VS Global Docs",
    "keywords": "Class Payload Namespace VsGlobal.Proto Assembly VSGlobal.dll [ProtoContract] public class Payload Inheritance object Payload Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods PayloadExtensionMethods.DeserializePacket<T>(Payload) PayloadExtensionMethods.Serialize<T>(Payload, T) Constructors Payload() public Payload() Payload(string) public Payload(string module) Parameters module string Properties Module [ProtoMember(1)] public string Module { get; set; } Property Value string PacketType [ProtoMember(3)] public string PacketType { get; set; } Property Value string PacketValue [ProtoMember(4)] public byte[] PacketValue { get; set; } Property Value byte[] Processed [ProtoMember(2)] public bool Processed { get; set; } Property Value bool Methods Deserialize(byte[], int) public static Payload Deserialize(byte[] buffer, int responseSize) Parameters buffer byte[] responseSize int Returns Payload"
  },
  "api/VsGlobal.Proto.PayloadExtensionMethods.html": {
    "href": "api/VsGlobal.Proto.PayloadExtensionMethods.html",
    "title": "Class PayloadExtensionMethods | VS Global Docs",
    "keywords": "Class PayloadExtensionMethods Namespace VsGlobal.Proto Assembly VSGlobal.dll public static class PayloadExtensionMethods Inheritance object PayloadExtensionMethods Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeserializePacket<T>(Payload) public static T? DeserializePacket<T>(this Payload payload) Parameters payload Payload Returns T Type Parameters T Serialize<T>(Payload, T) public static byte[] Serialize<T>(this Payload payload, T packetValue) Parameters payload Payload packetValue T Returns byte[] Type Parameters T"
  },
  "api/VsGlobal.Proto.html": {
    "href": "api/VsGlobal.Proto.html",
    "title": "Namespace VsGlobal.Proto | VS Global Docs",
    "keywords": "Namespace VsGlobal.Proto Classes Payload PayloadExtensionMethods"
  },
  "api/VsGlobal.html": {
    "href": "api/VsGlobal.html",
    "title": "Namespace VsGlobal | VS Global Docs",
    "keywords": "Namespace VsGlobal Classes Events Events allows you to add callbacks to VsGlobal events. Using a lambda: Events.OnConnect += (e) => {}; // Where e is type OnConnectEventArgs Using a function: public void MyCustomHandler(OnPayloadReceivedEventArgs e) { Console.WriteLine(e.payload.Module); // \"core\" } Events.OnPayloadReceived += MyCustomHandler; Network Structs Config Contains the api, player, their auth_token and module (\"core\")."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | VS Global Docs",
    "keywords": "Getting Started Installation - WIP :^) Download and install the VSGlobal mod from the ModDB. Add the following package reference to your .csproj file and make sure it is exclude it from the build process. <PackageReference Include=\"VSGlobal\" Version=\"1.0.0\"> <Private>true</Private> <PrivateAssets>all</PrivateAssets> </PackageReference> Once that's done, you're ready to work with the VSGlobal API. Here's an example of what a simple mod may look like: public class MyModSystem : ModSystem { string channel = \"my_string_channel\"; public override void StartClientSide(ICoreClientAPI api) { // Add our custom payload handler that is called whenever we receive a packet. // We can even say `+= async (e)` here and await a long running task. Events.OnPayloadReceived += (e) => { if (e.payload.Module == channel) { string message = e.payload.DeserializePacket<string>() ?? \"VSG: Couldn't parse message!\"; Console.WriteLine(message); // If we wanted to do anything in the game though, we'll need to be on the main thread! api.Events.EnqueueMainThreadTask(() => api.ShowChatMessage($\"Received a payload: {message}\"), \"MTT_MyModPayloadReceived\"); } }; // Add our custom event for when VSGlobal connects (VSGlobal loads at level 0) Events.OnConnect += async (args) => { await Network.Subscribe(channel); // I'm sure this can be made async but.... Time is not a luxury I have. this.api.Event.OnSendChatMessage += MyChatMessageHandler; }; base.StartClientSide(this.api); } private void MyChatMessageHandler(int groupId, ref string message, ref EnumHandling handled) { // All this can be called `async` and is awaitable. I highly recommend you do this to enhance performance. Task.Run(async () => await Network.Broadcast($\"Message from VSGlobal's server! - {threadedMessage}\", channel)); // handled = EnumHandling.PreventSubsequent; // If we wanted to brick all native functionality and just test, this would be the way to do it. } } Keep in mind, we can replace giving it a string value for any type we'd like to send. We can send native Vintage Story Protobuf packets, we can send structs, classes and potentially even functions/tasks we can invoke once it's received. // Sending large data is possible, but not entirely recommended. Bigger packets, bigger cost. Keep it simple if possible. Broadcast(api.World.Player, \"my_channel\") //> OnPayloadReceived - e.payload.DeserializePacket<IPlayer>() == Their player. // Untested use case but probably possible. Broadcast(EnumThingo.Grundle, \"my_channel\") //> OnPayloadReceived - e.payload.DeserializePacket<EnumThingo>() == EnumThingo.Grundle // Untested use case but probably possible. Broadcast(()=>{ return \"Someone test this for me, please! - Lila\"; }, \"my_channel\"); //> OnPayloadReceived - e.payload.DeserializePacket<??????>().Invoke(); // The list goes on. It's generic; go apeshit. Now you're familiar with the basics, you can look into the detailed API docs!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to VSGlobal! | VS Global Docs",
    "keywords": "Welcome to VSGlobal! A nifty networking solution for lazy people. Clientside only, lets you send and receive data to anyone on the VSGlobal network. So someone in one singleplayer world can receive a packet from someone in another singleplayer world. Cool for stuff like: A global chat (in progress) Sending items across servers / worlds A global marketplace Broadcast to everyone that you were eaten by a wolf again Dip down into the Guides Dive deep into the Docs"
  }
}